Учим бота ездить не натыкаясь на стены и препятствия

Используем радар.
Объект радар находится на боте и при вызове функции ScanRadar(angle)
 сканирует уровень на 150 метров, возвращая результаты во встроенные переменные. 
Для переменных Obstacle и wall возвращаются расстояния до места пересечения луча 
радара с плоскостью препятствия прямо по курсу радара.
Для остальных переменных (frend, enemy, bulletBonus, rocketBonus, RepairBonus)
радар возвращает хендлы объектов в секторе +\- 10.

(angle -абсолютный угол в градусах на который будет повернут радар при сканировании)
сканируем в соответствии с направлением бота:

 ScanRadar(corpusyaw)              ;в переменной corpusyaw у нас содержится текущий угол бота по оси У
 if (Obstacle>0) and (Obstacle<400);переменные Obstacle содержит расстояние до препятствия, если оно есть
     Turn_C=20                     ; наша переменная принимает значение если расстояние меньше 40 метров, назовем ее счетчик
      oba=ObsAngle                 ; в переменную oba запоминаем угол с этим препятствием относительно бота
  endif
;----------------------выполняем маневр
if Turn_C>0         ; если счетчик больше 0
   Turn_C=Turn_C-1  ; уменьшаем счетчик
   TurnCorpus=oba   ;бот будет поворачиваться соответственно с углом между препятствием и ботом
endif

move=1  ; двигаем бота

Иногда все же бот утыкается в стенки и препятствия.
Используем переменные CollidedObstacle% и CollidedWalls%
 
if CollidedObstacle%<>0                        ; если есть столкновение
 if (turn_b1=0)and(turn_b2=0)                   ; если маневр уже не начат
  turn_b1=60                                    ; включаем первый счетчик маневра
 endif
endif
Выполняем маневр: отъехать назад, повернуть вправо, ехать вперед, поворачивая влево.
Для этого используем две переменные для наглядности
переменная turn_b1 отвечает за первые две фазы: ехать назад и поворачивать вправо
после того. как как вторая фаза заканчивается, используем вторую переменную turn_b2
которая отвечает за третью фазу : ехать вперед, поворачивая влево
if turn_b1>0                                    ; если счетчик включен
   turn_b1=turn_b1-1
   if turn_b1=0                                 ; если счетчик отработал
      turn_b2=50                                ; запускаем второй счетчик
   endif
move=-1                                         ;двигаем бота назад
  if turn_b1<40                                 ; если счетчик меньше 40
   TurnCorpus=-1                                ; поворачиваем влево
  endif
endif

if turn_b2>0                                    ;если второй счетчик включен        
   turn_b2=turn_b2-1
   move=1                                       ;двигаем бота вперед
   TurnCorpus=1                                 ;поворачиваем вправо
endif

Естественно данный код не совершенен и требует корректировки. Но главное - он работает :)